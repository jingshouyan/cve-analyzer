package main

import (
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/scylladb/termtables"
	"gopkg.in/gomail.v2"
)

type vlun struct {
	Dependency    string `json:"DependencyName"`
	Cve           string `json:"CVE"`
	V2score       string `json:"CVSSv2_Score"`
	V3score       string `json:"CVSSv3_BaseScore"`
	Suggestion    string `json:"Suggestion"`
	Vulnerability string `json:"Vulnerability"`
}

type vluns []*vlun

var in = flag.String("in", "", "dependency-check-report.csv file path")

var out = flag.String("out", "", "out csv file path")

var email = flag.String("email", "", "email info,format: user|password|host|port|to")

func main() {
	flag.Parse()
	if *in == "" {
		panic("dependency-check-report.csv file path is empty")
	}
	if *out == "" {
		panic("out path is empty")
	}

	allVluns, err := loadVluns(*in)
	if err != nil {
		panic(err)
	}
	knownVluns, err := loadVluns(*out)
	if err != nil {
		panic(err)
	}
	newVluns := allVluns.minus(knownVluns)
	historyVluns := knownVluns.minus(allVluns)
	historyVluns.markHistory()
	knownVluns = append(knownVluns, newVluns...)
	knownVluns.print()
	err = knownVluns.exportCsv(*out)
	if err != nil {
		panic(err)
	}
	knownVluns.exportMarkdown(*out + ".md")

	if len(newVluns) > 0 {
		newVluns.email()
	}

}

func appendCsv(csvPath string, vs vluns) error {
	f, err := os.OpenFile(csvPath, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()
	writer := csv.NewWriter(f)
	defer writer.Flush()
	for _, v := range vs {
		record := []string{v.Dependency, v.Cve, v.Suggestion}
		err = writer.Write(record)
	}
	if err != nil {
		return err
	}
	return nil
}

func loadVluns(csvPath string) (vluns, error) {
	var vs vluns
	_, err := os.Stat(csvPath)

	if err != nil && os.IsNotExist(err) {
		return vs, nil
	}
	f, err := os.Open(csvPath)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	reader := csv.NewReader(f)

	result, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}

	headIndex := make(map[int]string)
	for i, v := range result[0] {
		headIndex[i] = v

	}

	for i := 1; i < len(result); i++ {
		vm := make(map[string]string)

		v := new(vlun)
		for j, value := range result[i] {
			vm[headIndex[j]] = value
		}
		jsonData, err := json.Marshal(vm)
		if err != nil {
			return nil, err
		}
		err = json.Unmarshal(jsonData, v)
		vs = append(vs, v)
	}
	return vs, nil
}

func (v vluns) minus(v2 vluns) vluns {
	var c3 vluns
	for _, value := range v {
		if !v2.contains(value) {
			c3 = append(c3, value)
		}
	}
	return c3
}

func (v vluns) contains(c2 *vlun) bool {
	for _, value := range v {
		if value.Dependency == c2.Dependency && value.Cve == c2.Cve {
			// 这里赋值好像不太好
			value.Vulnerability = c2.Vulnerability
			value.V2score = c2.V2score
			value.V3score = c2.V3score
			return true
		}
	}
	return false
}

func (c vluns) print() {
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.Dependency, v.Cve, v.Suggestion, v.Vulnerability)
	}
	fmt.Println(t.Render())
	for _, v := range c {
		j, _ := json.Marshal(v)
		fmt.Println(string(j))
	}
}

func (c vluns) exportCsv(csvPath string) error {
	os.MkdirAll(path.Dir(csvPath), os.ModePerm)
	f, err := os.Create(csvPath)
	if err != nil {
		return err
	}
	defer f.Close()
	writer := csv.NewWriter(f)
	defer writer.Flush()
	r := []string{"DependencyName", "CVE", "CVSSv2_Score", "CVSSv3_BaseScore", "Suggestion", "Vulnerability"}

	err = writer.Write(r)
	for _, v := range c {
		record := []string{v.Dependency, v.Cve, v.V2score, v.V3score, v.Suggestion, v.Vulnerability}
		err = writer.Write(record)
	}
	if err != nil {
		return err
	}
	return nil
}

func (c vluns) exportMarkdown(mdPath string) error {
	os.MkdirAll(path.Dir(mdPath), os.ModePerm)
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "CVSSv2_Score", "CVSSv3_BaseScore", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.Dependency, v.Cve, v.V2score, v.V3score, v.Suggestion, v.Vulnerability)
	}
	t.SetModeMarkdown()
	f, err := os.Create(mdPath)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.WriteString(t.Render())
	return err
}

const historyMark = "**history** "

func (c vluns) markHistory() {
	for _, v := range c {
		if !strings.HasPrefix(v.Suggestion, historyMark) {
			v.Suggestion = historyMark + v.Suggestion
		}

	}
}

func (c vluns) email() error {
	if *email == "" {
		fmt.Println("email address is empty")
		return nil
	}
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.Dependency, v.Cve, v.Suggestion, v.Vulnerability)
	}
	info := strings.Split(*email, "|")
	user := info[0]
	pass := info[1]
	host := info[2]
	port, err := strconv.Atoi(info[3])
	if err != nil {
		return err
	}
	to := user
	if len(info) > 4 {
		to = info[4]
	}
	tos := strings.Split(to, ";")
	m := gomail.NewMessage()
	//发送人
	m.SetHeader("From", user)
	//接收人
	m.SetHeader("To", tos...)
	//抄送人
	//m.SetAddressHeader("Cc", "xxx@qq.com", "xiaozhujiao")
	//主题
	m.SetHeader("Subject", "CVE漏洞提醒")
	//内容
	m.SetBody("text/html", t.RenderHTML())
	//附件
	//m.Attach("./myIpPic.png")

	//拿到token，并进行连接,第4个参数是填授权码
	d := gomail.NewDialer(host, port, user, pass)

	// 发送邮件
	if err := d.DialAndSend(m); err != nil {
		fmt.Printf("DialAndSend err %v:", err)
		panic(err)
	}
	fmt.Printf("send mail success\n")
	return nil
}
