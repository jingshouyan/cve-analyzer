package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/scylladb/termtables"
)

type vlun struct {
	dependency    string
	cve           string
	suggestion    string
	vulnerability string
}

type vluns []*vlun

var in = flag.String("in", "", "dependency-check-report.csv file path")

var out = flag.String("out", "", "out csv file path")

func main() {
	flag.Parse()
	if *in == "" {
		panic("dependency-check-report.csv file path is empty")
	}
	if *out == "" {
		panic("out path is empty")
	}

	allVluns, err := loadVluns(*in)
	if err != nil {
		panic(err)
	}
	knownVluns, err := loadVluns(*out)
	if err != nil {
		panic(err)
	}
	newVluns := allVluns.minus(knownVluns)
	historyVluns := knownVluns.minus(allVluns)
	historyVluns.markHistory()
	knownVluns = append(knownVluns, newVluns...)
	knownVluns.print()
	err = knownVluns.exportCsv(*out)
	if err != nil {
		panic(err)
	}
}

func appendCsv(csvPath string, vs vluns) error {
	f, err := os.OpenFile(csvPath, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()
	writer := csv.NewWriter(f)
	defer writer.Flush()
	for _, v := range vs {
		record := []string{v.dependency, v.cve, v.suggestion}
		err = writer.Write(record)
	}
	if err != nil {
		return err
	}
	return nil
}

func loadVluns(csvPath string) (vluns, error) {
	var vs vluns
	_, err := os.Stat(csvPath)

	if err != nil && os.IsNotExist(err) {
		return vs, nil
	}
	f, err := os.Open(csvPath)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	reader := csv.NewReader(f)

	result, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}
	dependencyIndex := -1
	cveIndex := -1
	suggestionIndex := -1
	vulnerabilityIndex := -1
	for i, v := range result[0] {
		if v == "DependencyName" {
			dependencyIndex = i
		}
		if v == "CVE" {
			cveIndex = i
		}
		if v == "Suggestion" {
			suggestionIndex = i
		}
		if v == "Vulnerability" {
			vulnerabilityIndex = i
		}
	}

	for i := 1; i < len(result); i++ {
		v := new(vlun)
		for j, value := range result[i] {
			if dependencyIndex == j {
				v.dependency = value
			}
			if cveIndex == j {
				v.cve = value
			}
			if suggestionIndex == j {
				v.suggestion = value
			}
			if vulnerabilityIndex == j {
				v.vulnerability = value
			}
		}
		vs = append(vs, v)
	}
	return vs, nil
}

func (v vluns) minus(v2 vluns) vluns {
	var c3 vluns
	for _, value := range v {
		if !v2.contains(value) {
			c3 = append(c3, value)
		}
	}
	return c3
}

func (v vluns) contains(c2 *vlun) bool {
	for _, value := range v {
		if value.dependency == c2.dependency && value.cve == c2.cve {
			// 这里赋值好像不太好
			value.vulnerability = c2.vulnerability
			return true
		}
	}
	return false
}

func (c vluns) print() {
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.dependency, v.cve, v.suggestion, v.vulnerability)
	}
	fmt.Println(t.Render())
}

func (c vluns) exportCsv(csvPath string) error {
	f, err := os.Create(csvPath)
	if err != nil {
		return err
	}
	defer f.Close()
	writer := csv.NewWriter(f)
	defer writer.Flush()
	r := []string{"DependencyName", "CVE", "Suggestion", "Vulnerability"}
	err = writer.Write(r)
	for _, v := range c {
		record := []string{v.dependency, v.cve, v.suggestion, v.vulnerability}
		err = writer.Write(record)
	}
	if err != nil {
		return err
	}
	return nil
}

const historyMark = "**history** "

func (c vluns) markHistory() {
	for _, v := range c {
		if !strings.HasPrefix(v.suggestion, historyMark) {
			v.suggestion = historyMark + v.suggestion
		}

	}
}
