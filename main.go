package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/scylladb/termtables"
	"gopkg.in/gomail.v2"
)

type vlun struct {
	dependency    string
	cve           string
	v2score       string
	v3score       string
	suggestion    string
	vulnerability string
}

type vluns []*vlun

var in = flag.String("in", "", "dependency-check-report.csv file path")

var out = flag.String("out", "", "out csv file path")

var email = flag.String("email", "", "email info,format: user|password|host|port|to")

func main() {
	flag.Parse()
	if *in == "" {
		panic("dependency-check-report.csv file path is empty")
	}
	if *out == "" {
		panic("out path is empty")
	}

	allVluns, err := loadVluns(*in)
	if err != nil {
		panic(err)
	}
	knownVluns, err := loadVluns(*out)
	if err != nil {
		panic(err)
	}
	newVluns := allVluns.minus(knownVluns)
	historyVluns := knownVluns.minus(allVluns)
	historyVluns.markHistory()
	knownVluns = append(knownVluns, newVluns...)
	knownVluns.print()
	err = knownVluns.exportCsv(*out)
	if err != nil {
		panic(err)
	}
	knownVluns.exportMarkdown(*out + ".md")

	if len(newVluns) > 0 {
		newVluns.email()
	}
}

func appendCsv(csvPath string, vs vluns) error {
	f, err := os.OpenFile(csvPath, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer f.Close()
	writer := csv.NewWriter(f)
	defer writer.Flush()
	for _, v := range vs {
		record := []string{v.dependency, v.cve, v.suggestion}
		err = writer.Write(record)
	}
	if err != nil {
		return err
	}
	return nil
}

func loadVluns(csvPath string) (vluns, error) {
	var vs vluns
	_, err := os.Stat(csvPath)

	if err != nil && os.IsNotExist(err) {
		return vs, nil
	}
	f, err := os.Open(csvPath)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	reader := csv.NewReader(f)

	result, err := reader.ReadAll()
	if err != nil {
		return nil, err
	}
	dependencyIndex := -1
	cveIndex := -1
	suggestionIndex := -1
	vulnerabilityIndex := -1
	v2scoreIndex := -1
	v3scoreIndex := -1
	for i, v := range result[0] {
		if v == "DependencyName" {
			dependencyIndex = i
		}
		if v == "CVE" {
			cveIndex = i
		}
		if v == "Suggestion" {
			suggestionIndex = i
		}
		if v == "Vulnerability" {
			vulnerabilityIndex = i
		}
		if v == "CVSSv2_Score" {
			v2scoreIndex = i
		}
		if v == "CVSSv3_BaseScore" {
			v3scoreIndex = i
		}
	}

	for i := 1; i < len(result); i++ {
		v := new(vlun)
		for j, value := range result[i] {
			if dependencyIndex == j {
				v.dependency = value
			}
			if cveIndex == j {
				v.cve = value
			}
			if suggestionIndex == j {
				v.suggestion = value
			}
			if vulnerabilityIndex == j {
				v.vulnerability = value
			}
			if v2scoreIndex == j {
				v.v2score = value
			}
			if v3scoreIndex == j {
				v.v3score = value
			}
		}
		vs = append(vs, v)
	}
	return vs, nil
}

func (v vluns) minus(v2 vluns) vluns {
	var c3 vluns
	for _, value := range v {
		if !v2.contains(value) {
			c3 = append(c3, value)
		}
	}
	return c3
}

func (v vluns) contains(c2 *vlun) bool {
	for _, value := range v {
		if value.dependency == c2.dependency && value.cve == c2.cve {
			// 这里赋值好像不太好
			value.vulnerability = c2.vulnerability
			value.v2score = c2.v2score
			value.v3score = c2.v3score
			return true
		}
	}
	return false
}

func (c vluns) print() {
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.dependency, v.cve, v.suggestion, v.vulnerability)
	}
	fmt.Println(t.Render())
}

func (c vluns) exportCsv(csvPath string) error {
	os.MkdirAll(path.Dir(csvPath), os.ModePerm)
	f, err := os.Create(csvPath)
	if err != nil {
		return err
	}
	defer f.Close()
	writer := csv.NewWriter(f)
	defer writer.Flush()
	r := []string{"DependencyName", "CVE", "CVSSv2_Score", "CVSSv3_BaseScore", "Suggestion", "Vulnerability"}
	err = writer.Write(r)
	for _, v := range c {
		record := []string{v.dependency, v.cve, v.v2score, v.v3score, v.suggestion, v.vulnerability}
		err = writer.Write(record)
	}
	if err != nil {
		return err
	}
	return nil
}

func (c vluns) exportMarkdown(mdPath string) error {
	os.MkdirAll(path.Dir(mdPath), os.ModePerm)
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "CVSSv2_Score", "CVSSv3_BaseScore", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.dependency, v.cve, v.v2score, v.v3score, v.suggestion, v.vulnerability)
	}
	t.SetModeMarkdown()
	f, err := os.Create(mdPath)
	if err != nil {
		return err
	}
	defer f.Close()
	_, err = f.WriteString(t.Render())
	return err
}

const historyMark = "**history** "

func (c vluns) markHistory() {
	for _, v := range c {
		if !strings.HasPrefix(v.suggestion, historyMark) {
			v.suggestion = historyMark + v.suggestion
		}

	}
}

func (c vluns) email() error {
	if *email == "" {
		fmt.Println("email address is empty")
		return nil
	}
	t := termtables.CreateTable()
	t.AddHeaders("DependencyName", "CVE", "Suggestion", "Vulnerability")
	for _, v := range c {
		t.AddRow(v.dependency, v.cve, v.suggestion, v.vulnerability)
	}
	info := strings.Split(*email, "|")
	user := info[0]
	pass := info[1]
	host := info[2]
	port, err := strconv.Atoi(info[3])
	if err != nil {
		return err
	}
	to := user
	if len(info) > 4 {
		to = info[4]
	}
	tos := strings.Split(to, ";")
	m := gomail.NewMessage()
	//发送人
	m.SetHeader("From", user)
	//接收人
	m.SetHeader("To", tos...)
	//抄送人
	//m.SetAddressHeader("Cc", "xxx@qq.com", "xiaozhujiao")
	//主题
	m.SetHeader("Subject", "CVE漏洞提醒")
	//内容
	m.SetBody("text/html", t.RenderHTML())
	//附件
	//m.Attach("./myIpPic.png")

	//拿到token，并进行连接,第4个参数是填授权码
	d := gomail.NewDialer(host, port, user, pass)

	// 发送邮件
	if err := d.DialAndSend(m); err != nil {
		fmt.Printf("DialAndSend err %v:", err)
		panic(err)
	}
	fmt.Printf("send mail success\n")
	return nil
}
